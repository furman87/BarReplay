<!DOCTYPE html>
<html>
<head>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
    }

    #chart {
      width: 100vw;
      height: 100vh;
    }
    </style>
</head>
<body>
    <input type="datetime-local" id="startTime">
    <select id="interval">
      <option value="1" selected>1</option>
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4">4</option>
      <option value="5">5</option>
      <option value="15">15</option>
      <option value="30">30</option>
      <option value="60">60</option>
    </select>
    <button onclick="startReplay()">Start Replay</button>
    <button onclick="loadNextBar()">Next</button>
    <button onclick="goToLatest()">»</button>
    <div id="chart"></div>

    <script>
        function pad(n) {
            return n.toString().padStart(2, '0');
        }

        const now = new Date();
        const formatted = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}T${pad(now.getHours())}:${pad(now.getMinutes())}`;
        document.getElementById('startTime').value = formatted;

        const serverUrl = window.location.origin;
        const chart = LightweightCharts.createChart(document.getElementById('chart'), {
            width: window.innerWidth - 25,
            height: window.innerHeight - 30,
            timeScale: {
                timeVisible: true,
                secondsVisible: false,
            },
            crosshair: {
                // Change mode from default 'magnet' to 'normal'.
                // Allows the crosshair to move freely without snapping to datapoints
                mode: LightweightCharts.CrosshairMode.Normal
            }
        });

        const series = chart.addSeries(LightweightCharts.CandlestickSeries, {
            upColor: '#35ce35',
            downColor: '#040404',
            borderVisible: true,
            borderUpColor: '#040404',
            borderDownColor: '#040404',
            wickUpColor: '#040404',
            wickDownColor: '#040404',
        });
        
        let lastTimestamp = null;

        async function startReplay() {
            const input = document.getElementById('startTime').value;
            const interval = getSelectedInterval();
            if (!input) return;
            const res = await fetch(`${serverUrl}/api/bars/${interval}/init?start=${input}`);
            const data = await res.json();
            series.setData(data);
            if (data.length > 0) {
                lastTimestamp = data[data.length - 1].time;
            }
        }

        async function loadNextBar() {
            if (!lastTimestamp) return;
            const afterDate = new Date(lastTimestamp * 1000).toISOString();
            const interval = getSelectedInterval();
            const res = await fetch(`${serverUrl}/api/bars/${interval}/next?after=${afterDate}`);
            const data = await res.json();
            if (data.length > 0) {
                series.update(data[0]);
                lastTimestamp = data[0].time;
                let formatted = unixToFormattedDate(lastTimestamp);
                document.getElementById('startTime').value = formatted;
                console.log("lastTimestamp = " + lastTimestamp + " formatted = " + formatted + " interval = " + interval);
            }
        }

        async function goToLatest() {
            chart.timeScale().scrollToRealTime();
        }
        
        function unixToFormattedDate(timestamp) {
            if (!timestamp) return;

            const date = new Date(timestamp * 1000); // convert to ms

            const month = (date.getUTCMonth() + 1).toString().padStart(2, '0');
            const day   = date.getUTCDate().toString().padStart(2, '0');
            const year  = date.getUTCFullYear();

            let hours = date.getUTCHours().toString().padStart(2, '0');
            const minutes = date.getUTCMinutes().toString().padStart(2, '0');

            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }
        
        function getSelectedInterval() {
            return document.getElementById('interval').value;
        }
        
        let loading = false;

        chart.timeScale().subscribeVisibleLogicalRangeChange(async (range) => {
            if (loading || !range) return;

            if (range.from < 5) { // close to the left edge
                loading = true;
                const oldestBar = series.data()[0];
                console.log(oldestBar);
                if (!oldestBar) return;

                const oldestDate = new Date(oldestBar.time * 1000).toISOString();
                const interval = getSelectedInterval();
                const res = await fetch(`${serverUrl}/api/bars/${interval}/before?time=${oldestDate}`);
                const olderBars = await res.json();

                if (olderBars.length > 0) {
                    // Prepend bars
                    series.setData([...olderBars, ...series.data()]);
                }

                loading = false;
            }
        });

    </script>
</body>
</html>
